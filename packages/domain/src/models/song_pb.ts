// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file song.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FloatValue, Int32Value, Message, proto3, StringValue, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message AudioFormat
 */
export class AudioFormat extends Message<AudioFormat> {
  /**
   * @generated from field: AudioFormat.Encoding encoding = 1;
   */
  encoding = AudioFormat_Encoding.UNKNOWN;

  /**
   * @generated from field: uint32 sampling_rate = 2;
   */
  samplingRate = 0;

  /**
   * @generated from field: uint32 bits = 3;
   */
  bits = 0;

  /**
   * @generated from field: uint32 channels = 4;
   */
  channels = 0;

  constructor(data?: PartialMessage<AudioFormat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "AudioFormat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encoding", kind: "enum", T: proto3.getEnumType(AudioFormat_Encoding) },
    { no: 2, name: "sampling_rate", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "bits", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "channels", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioFormat {
    return new AudioFormat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioFormat {
    return new AudioFormat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioFormat {
    return new AudioFormat().fromJsonString(jsonString, options);
  }

  static equals(a: AudioFormat | PlainMessage<AudioFormat> | undefined, b: AudioFormat | PlainMessage<AudioFormat> | undefined): boolean {
    return proto3.util.equals(AudioFormat, a, b);
  }
}

/**
 * @generated from enum AudioFormat.Encoding
 */
export enum AudioFormat_Encoding {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: PCM = 1;
   */
  PCM = 1,

  /**
   * @generated from enum value: DSD = 2;
   */
  DSD = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AudioFormat_Encoding)
proto3.util.setEnumType(AudioFormat_Encoding, "AudioFormat.Encoding", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "PCM" },
  { no: 2, name: "DSD" },
]);

/**
 * @generated from message Song
 */
export class Song extends Message<Song> {
  /**
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: map<string, Song.MetadataValue> metadata = 2;
   */
  metadata: { [key: string]: Song_MetadataValue } = {};

  /**
   * index can be used for the application specific usage. This is different
   * from MetadataTag.POSITION which is managed by MPD.
   *
   * @generated from field: int32 index = 3;
   */
  index = 0;

  constructor(data?: PartialMessage<Song>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Song";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Song_MetadataValue} },
    { no: 3, name: "index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Song {
    return new Song().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Song {
    return new Song().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Song {
    return new Song().fromJsonString(jsonString, options);
  }

  static equals(a: Song | PlainMessage<Song> | undefined, b: Song | PlainMessage<Song> | undefined): boolean {
    return proto3.util.equals(Song, a, b);
  }
}

/**
 * @generated from enum Song.MetadataTag
 */
export enum Song_MetadataTag {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: TITLE = 1;
   */
  TITLE = 1,

  /**
   * @generated from enum value: ARTIST = 2;
   */
  ARTIST = 2,

  /**
   * @generated from enum value: ALBUM_ARTIST = 3;
   */
  ALBUM_ARTIST = 3,

  /**
   * @generated from enum value: ALBUM = 4;
   */
  ALBUM = 4,

  /**
   * @generated from enum value: GENRE = 5;
   */
  GENRE = 5,

  /**
   * @generated from enum value: COMPOSER = 6;
   */
  COMPOSER = 6,

  /**
   * @generated from enum value: TRACK = 7;
   */
  TRACK = 7,

  /**
   * @generated from enum value: DISC = 8;
   */
  DISC = 8,

  /**
   * @generated from enum value: DATE = 9;
   */
  DATE = 9,

  /**
   * @generated from enum value: DURATION = 10;
   */
  DURATION = 10,

  /**
   * @generated from enum value: FORMAT = 11;
   */
  FORMAT = 11,

  /**
   * @generated from enum value: UPDATED_AT = 12;
   */
  UPDATED_AT = 12,

  /**
   * @generated from enum value: ID = 13;
   */
  ID = 13,

  /**
   * @generated from enum value: POSITION = 14;
   */
  POSITION = 14,

  /**
   * @generated from enum value: COMMENT = 15;
   */
  COMMENT = 15,

  /**
   * @generated from enum value: LABEL = 16;
   */
  LABEL = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(Song_MetadataTag)
proto3.util.setEnumType(Song_MetadataTag, "Song.MetadataTag", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "TITLE" },
  { no: 2, name: "ARTIST" },
  { no: 3, name: "ALBUM_ARTIST" },
  { no: 4, name: "ALBUM" },
  { no: 5, name: "GENRE" },
  { no: 6, name: "COMPOSER" },
  { no: 7, name: "TRACK" },
  { no: 8, name: "DISC" },
  { no: 9, name: "DATE" },
  { no: 10, name: "DURATION" },
  { no: 11, name: "FORMAT" },
  { no: 12, name: "UPDATED_AT" },
  { no: 13, name: "ID" },
  { no: 14, name: "POSITION" },
  { no: 15, name: "COMMENT" },
  { no: 16, name: "LABEL" },
]);

/**
 * @generated from message Song.MetadataValue
 */
export class Song_MetadataValue extends Message<Song_MetadataValue> {
  /**
   * @generated from oneof Song.MetadataValue.value
   */
  value: {
    /**
     * @generated from field: google.protobuf.StringValue string_value = 2;
     */
    value: StringValue;
    case: "stringValue";
  } | {
    /**
     * @generated from field: google.protobuf.Int32Value int_value = 3;
     */
    value: Int32Value;
    case: "intValue";
  } | {
    /**
     * @generated from field: google.protobuf.FloatValue float_value = 4;
     */
    value: FloatValue;
    case: "floatValue";
  } | {
    /**
     * @generated from field: AudioFormat format = 5;
     */
    value: AudioFormat;
    case: "format";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp timestamp = 6;
     */
    value: Timestamp;
    case: "timestamp";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Song_MetadataValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Song.MetadataValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "string_value", kind: "message", T: StringValue, oneof: "value" },
    { no: 3, name: "int_value", kind: "message", T: Int32Value, oneof: "value" },
    { no: 4, name: "float_value", kind: "message", T: FloatValue, oneof: "value" },
    { no: 5, name: "format", kind: "message", T: AudioFormat, oneof: "value" },
    { no: 6, name: "timestamp", kind: "message", T: Timestamp, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Song_MetadataValue {
    return new Song_MetadataValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Song_MetadataValue {
    return new Song_MetadataValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Song_MetadataValue {
    return new Song_MetadataValue().fromJsonString(jsonString, options);
  }

  static equals(a: Song_MetadataValue | PlainMessage<Song_MetadataValue> | undefined, b: Song_MetadataValue | PlainMessage<Song_MetadataValue> | undefined): boolean {
    return proto3.util.equals(Song_MetadataValue, a, b);
  }
}

/**
 * @generated from message SongList
 */
export class SongList extends Message<SongList> {
  /**
   * @generated from field: repeated Song songs = 1;
   */
  songs: Song[] = [];

  constructor(data?: PartialMessage<SongList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "SongList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "songs", kind: "message", T: Song, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SongList {
    return new SongList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SongList {
    return new SongList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SongList {
    return new SongList().fromJsonString(jsonString, options);
  }

  static equals(a: SongList | PlainMessage<SongList> | undefined, b: SongList | PlainMessage<SongList> | undefined): boolean {
    return proto3.util.equals(SongList, a, b);
  }
}

